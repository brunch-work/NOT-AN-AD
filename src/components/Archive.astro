---
import { calcGeneratorDuration } from "motion/react";
import { archiveQuery, lightboxQuery, type Asset } from "../gql/queries";
import { Lightbox } from "./Lightbox.jsx";
import { Image } from "astro:assets";
import { Logo } from "./Icons/Logo";

type ProjectData = {
  id: string;
  clientName: string;
  projectType: string;
  publicationDate: string;
};

const response = await fetch("https://graphql.datocms.com/", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
    Accept: "application/json",
    Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,
  },
  body: JSON.stringify({
    query: archiveQuery,
  }),
});

const json = await response.json();
const data = json.data;
const assets: Asset[] = data.archive.assets;
const initialIndex = 0;

// Fetch project data for each asset
const projectDataMap: Record<string, ProjectData> = {};
for (const asset of assets) {
  try {
    const projectResponse = await fetch("https://graphql.datocms.com/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Accept: "application/json",
        Authorization: `Bearer ${import.meta.env.DATOCMS_API_KEY}`,
      },
      body: JSON.stringify({
        query: lightboxQuery,
        variables: {
          id: [asset.id],
        },
      }),
    });

    const projectJson = await projectResponse.json();
    if (projectJson.data?.project) {
      projectDataMap[asset.id] = projectJson.data.project;
    }
  } catch (error) {
    console.error(`Error fetching project for asset ${asset.id}:`, error);
  }
}
---

<div class="subgrid archive">
  {
    assets.map((asset: Asset, index: number) => {
      if (asset.format === "jpg" || asset.format === "png") {
        return (
          <div class="archive-item">
            <button
              data-lightbox-trigger
              data-asset-index={index}
              aria-label={`View ${asset.alt || "image"}`}
            >
              <div
                class="archive-item-media"
                style={`background-image: url('${asset.responsiveImage.base64}'); aspect-ratio: ${asset.responsiveImage.aspectRatio}`}
              >
                <img
                  src={asset.responsiveImage.src}
                  alt={asset.responsiveImage.alt}
                  srcset={asset.responsiveImage.webpSrcSet}
                  sizes={asset.responsiveImage.sizes}
                  width={asset.responsiveImage.width}
                  height={asset.responsiveImage.height}
                  loading="lazy"
                  decoding="async"
                />
              </div>
            </button>
          </div>
        );
      }
      if (
        asset.format === "mp4" ||
        asset.format === "webm" ||
        asset.format === "mov"
      ) {
        return (
          <div class="archive-item">
            <button
              data-lightbox-trigger
              data-asset-index={index}
              data-video-preview
              aria-label={`View ${asset.alt || "video"}`}
            >
              <div
                class="archive-item-media"
                style={`aspect-ratio: ${asset.video.width / asset.video.height}`}
              >
                <video
                  data-src={asset.video.mp4Url}
                  poster={asset.video.thumbnailUrl}
                  muted
                  preload="none"
                />
              </div>
            </button>
          </div>
        );
      }
    })
  }
</div>
<dialog id="lightbox-dialog" class="lightbox-dialog">
  <div class="grid">
    <div class="subgrid">
      <div id="lightbox-wrapper" class="lightbox-wrapper">
        <Lightbox
          client:load
          assets={assets}
          index={initialIndex}
          projectDataMap={projectDataMap}
          isDeck={false}
        />
      </div>
    </div>
  </div>
</dialog>

<script>
  const triggers = document.querySelectorAll("[data-lightbox-trigger]");
  const dialog = document.getElementById(
    "lightbox-dialog",
  ) as HTMLDialogElement | null;

  triggers.forEach((trigger) => {
    trigger.addEventListener("click", (e) => {
      const index = parseInt(
        trigger.getAttribute("data-asset-index") || "0",
        10,
      );

      // Dispatch custom event to update the lightbox index
      window.dispatchEvent(
        new CustomEvent("openLightbox", { detail: { index } }),
      );

      if (dialog) {
        dialog.classList.toggle("show");
      }
    });
  });

  // Close dialog on outside click
  if (dialog) {
    dialog.addEventListener("click", (e) => {
      const rect = dialog.getBoundingClientRect();
      const isInDialog =
        rect.top <= e.clientY &&
        e.clientY <= rect.top + rect.height &&
        rect.left <= e.clientX &&
        e.clientX <= rect.left + rect.width;

      if (!isInDialog) {
        dialog.close();
      }
    });
  }

  // Blur-up: reveal images once fully loaded
  const archiveImages = document.querySelectorAll(".archive-item-media img");
  archiveImages.forEach((img) => {
    const container = img.closest(".archive-item-media");
    if ((img as HTMLImageElement).complete) {
      container?.classList.add("is-loaded");
    } else {
      img.addEventListener("load", () => {
        container?.classList.add("is-loaded");
      });
    }
  });

  // Lazy load videos via IntersectionObserver
  const loadVideo = (video: HTMLVideoElement) => {
    const src = video.getAttribute("data-src");
    if (src && !video.src) {
      video.src = src;
      video.preload = "metadata";
      video.load();
      video.addEventListener(
        "loadeddata",
        () => {
          video.closest(".archive-item-media")?.classList.add("is-loaded");
        },
        { once: true },
      );
    }
  };

  const videoObserver = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          loadVideo(entry.target as HTMLVideoElement);
          videoObserver.unobserve(entry.target);
        }
      });
    },
    { rootMargin: "200px 0px" },
  );

  document.querySelectorAll("video[data-src]").forEach((video) => {
    videoObserver.observe(video);
  });

  // Video preview on hover
  const videoTriggers = document.querySelectorAll("[data-video-preview]");

  videoTriggers.forEach((trigger) => {
    const video = trigger.querySelector("video") as HTMLVideoElement | null;
    if (!video) return;

    let isHovering = false;

    const handleTimeUpdate = () => {
      if (isHovering && video.currentTime >= 2) {
        video.currentTime = 0;
      }
    };

    trigger.addEventListener("mouseenter", async () => {
      isHovering = true;
      // Ensure the video src is loaded before attempting playback
      if (!video.src) {
        loadVideo(video);
      }
      video.currentTime = 0;
      video.addEventListener("timeupdate", handleTimeUpdate);

      try {
        await video.play();
      } catch (error) {
        console.error("Error playing video preview:", error);
      }
    });

    trigger.addEventListener("mouseleave", () => {
      isHovering = false;
      video.pause();
      video.currentTime = 0;
      video.removeEventListener("timeupdate", handleTimeUpdate);
    });
  });
</script>
